# 位运算

### 1.原码、反码和补码

##### 二进制有三种表示形式：原码、反码和补码，计算机内部用补码表示。

###### 原码：二进制表示（最高位是符号位）

00 00 00 11   即3

10 00 00 11   即-3

###### 反码：正数的反码即原码；负数的反码为符号位不变，其余位取反

00 00 00 11   即3

11 11 11 00   即-3

###### 补码:正数的补码是源码，负数的补码是反码+1

00 00 00 11   即3

11 11 11 01   即-3

###### 符号位：最高位即符号位，0表示正数，1表示复数。位运算中符号位参与运算

### 2.按位非操作

~1 = 0     ~0 = 1

~把num的补码取反（有符号整数的符号位同样取反）

  00 00 01 01   ——  5

~00 00 01 01   

  11 11 10 10   —— -6（这是补码还是反码。。。没太搞懂为什么是-6）

  11 11 10 11   —— -5

~11 11 10 11   

  00 00 01 00   —— -4

### 3.按位与操作&

仅当两个对应位都为1时为1

### 4.按位或操作|

仅当两个对应位都为0时为0

### 5.按位异或操作^

仅当两个对应位不同时为1

1^1=0

1^0=1

0^1=1

0^0=0

异或操作满足交换律和结合律

A\^B=B\^A

A\^B\^A=A\^A\^B

### 6.按位左移操作<<

num << i 为将num的二进制表示向左移动i位所得的值

00 00 10 11——11

11<<3

01 01 10 00——88

### 按位右移操作>>

num >> i 为将 num 的二进制表示向右移动 i 位所得值

00 00 10 11——11

11>>2

00 00 00 10——2

### 8.利用位运算实现快速运算

+ 通过<<  >> 快速计算2的倍数问题

  n << 1   ——计算n\*2

  n >> 1   ——计算 n/2，负奇数的运算不可用

  n << m  ——计算 n*(2^m)，即乘以 2 的 m 次方

  n >> m  —— 计算 n/(2^m)，即除以 2 的 m 次方

  1 << n    ——2^n

+ 通过 ^ 快速交换两个整数

  a ^ = b

  b ^ = a

+ 通过 a & (-a) 快速获取 a 的最后为 1 位置的整数

  00 00 01 01           00 00 11 10

  &                             &

  11 11 10 11           11 11 00 10

  00 00 00 01           00 00 00 10

### 9.利用位运算实现整数集合

二进制表示可以看作是一个集合，0表示不在集合中，1表示在集合中

集合{1，3，4，8}，可表示成01 00 01 10 10 由此对应的位运算可以看作是对集合的操作

（上面这个是从0开始数的吧）

+ 元素与集合的操作：

  a | (1<<i)      —— 把 i 插入到集合中
  a & ~(1<<i)   —— 把 i 从集合中删除
  a & (1<<i)     —— 判断 i 是否属于该集合（零不属于，非零属于）

+ 集合之间的操作：

  a 补      —— ~a
  a 交 b   —— a & b
  a 并 b   —— a | b
  a 差 b   —— a & (~b)

**整数在内存中是以补码形式存在的，输出自然也按照补码输出**

+ Python中 bin 一个负数，输出的是它的原码的二进制表示加负号。
+ Python中的整型是补码形式存储的
+ Python中整型是不限制长度

为了获得负数的补码，需要手动将其与十六进制数0xffffffff进行按位与操作，再交给bin()输出，得到的才是负数的补码表示

